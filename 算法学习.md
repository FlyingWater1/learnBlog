## 准备工作
1 测试的数组都用Comparable的 ,Integer,Double都是事先了Comparable接口的.这样可以方便的切换类型
2 算法学习中常用到,比大小,交换,打印数组等
```
/**
 * 算法学习中使用到的常用操作
 */
public class Common {
    /**
     * 对比两个元素的大小
     * @param a
     * @param b
     * @return  true   a < b
     *          false  a >=b
     */
    public static boolean less(Comparable a,Comparable b){
        if (a.compareTo(b) < 0){
            return true;
        }else {
            return false;
        }
    }

    /**
     * 将数组a中的第i元素和第j元素交换位置
     * @param a
     * @param i
     * @param j
     */
    public static void exchange(Comparable[] a ,int i ,int j){
        Comparable ai = a[i];
        a[i] = a[j];
        a[j] = ai;
    }

    /**
     * 打印数组a
     * @param tag 额外的信息
     * @param a
     */
    public static void show(String tag,Comparable[] a){
        System.out.print(tag+": ");
        for (int i = 0 ; i< a.length ;i++){
            System.out.print(a[i].toString()+ " ");
        }
        System.out.println();
    }

    /**
     * 1 先把from拿出来
     * 2 把to(包含to)到from之间的后移一位
     * 3 把from放入到to的位置
     * @param a
     * @param from
     * @param to
     */
    public static void insert(Comparable[] a,int from,int to){
        Comparable aFrom = a[from];
        for (int i = from -1 ; i >= to ; i--){
            exchange(a,i,i+1);
        }
        a[to] = aFrom;

    }
}
```

## 选择排序
1. 找到数组中最小的那个,与第一位交换位置.
2. 在剩下的数组中重复1操作
3. 一直循环到最后一次

```
public class Selection {

    /**
     * 选择排序的实现
     * @param a
     */
    public static void sort(Comparable[] a){
        //打印进入时的数组
        Common.show("Selection start ",a);
        //选择排序不管初始的数组如何,总会循环N-1次
        //对10个元素排序,前面9个选择完了,第10个肯定是最大的
        for (int i = 0;i <a.length-1 ;i++){
            int minPos = i;
            //先简单点想,i=0的时候,从0开始到a.length-1结束,与最小值一一对比,如果小于最小值,就标记出来
            for (int j = i ; j  < a.length ; j++){
                if (less(a[j],a[minPos])){
                    minPos = j;
                }
            }
            //一趟比完了才能进行交换,千万不能在对比的途中进行交换,对比的途中最小值有可能会变很多次
            //如果是对比途中交换,就变成了冒泡排序
            exchange(a,i,minPos);
        }
        Common.show("Selection end",a);
    }
}
```
测试
```
public class main {

    public static void main(String[] arg){
        Selection.sort(values());
    }

    /**
      * @return 返回10个小于100的随机数
    */
    public static Comparable<Integer>[] values(){
        Random random = new Random();

        int itemCount = 10;
        Comparable<Integer>[] item = new Comparable[itemCount];
        for (int i = 0 ; i < itemCount ;i++){
            item[i] = random.nextInt(100);
        }
        return item;
    }
}
```
测试结果
```
Selection start : 94 25 49 98 68 45 78 33 21 21
Selection end: 21 21 25 33 45 49 68 78 94 98
```

## 插入排序
将数插入到已经排序好的数组中,其余元素往右移动一位,叫插入排序.
1 当前索引左边的都是有序的,但是有可能会移动,因为有可能会有个数在左边插入
2 与选择排序相比,如果数组中很多的数都是有序的,排序会比插入快很多

```
/**
 * 插入排序(升序)
 *   以i为索引,i左边的(包含i)都是有序的,右边的是还未排序的,
 *   从i+1开始与左边数组对比,如果大于左一位,对比结束,否则冒泡往左移动
 */
public class Insertion {

    /**
       * 这个是一个一个的往左对比,然后交换,左边的对比操作很像冒泡
       * @param a
    */
    public static void sort(Comparable[] a){
        Common.show("insertion start ",a);
        // 0到i都是已经排序过的,这里以i为索引
        // j到a.length-1是未排序过的
        int row = 1;
        for (int i = 0 ;i< a.length ; i++){
            //第一位跳过,直接让第二位与第一位做对比
            for (int j = i+1 ; j >0 ; j--){
                //下一位越界的时候说明都排序完了
                if (j == a.length){
                    break;
                }
                //初始化的时候,j是索引的后一位
                //a[j]与左边的数组逐次对比,如果a[j]小于左一位就交换,但是左二位有可能更小,所以还需要继续对比继续交换,与冒泡类似
                //a[j]大于左一位的话就不需要对比了,一位左边数组已经是升序排列了,左边数组的最右边就是最大的
                if (Common.less(a[j],a[j-1])){
                    Common.exchange(a,j,j-1);
                }else {
                    break;
                }
            }
            Common.show("insertion row " + row++ ,a);
        }
        Common.show("insertion end ",a);
    }


    /**
   * 这个是找到需要插入的位置后,数组右移,然后直接插入.这个就比较像选择排序了
   * @param a
   */
  public static void sortDirectMove(Comparable[] a){
      Common.show("insertion start ",a);
      // 0到i都是已经排序过的,这里以i为索引
      // j到a.length-1是未排序过的
      int row = 1;
      for (int i = 0 ;i< a.length ; i++){
          int  to = i;
          int  index = i;
          for (int j = i-1 ; j >=0 ; j--){
              //要升序排列  a[index] > a[j]后排序结束,因为a[0]到a[j]是有序的且是升序排列的
              // 1 a[index] 拿出
              // 2 a[j+1] 到a[index -1] 后移一位
              // 3 a[index] 插入到 a[j+1]
              if (Common.less(a[index],a[j])){
                  to = j;
              }else {
                  break;
              }

          }
          Common.insert(a,i,to);

          Common.show("insertion row " + row++ ,a);
      }
      Common.show("insertion end ",a);
  }
}

```
结果:第一趟就是 40,83对比,是有序的没有交换,第二趟是40,83,29对比,29逐步往左移动到第一位编程29,40,83.索引位左边的永远都是有序的
```
insertion start : 40 83 29 15 79 65 70 9 49 17
insertion row 1: 40 83 29 15 79 65 70 9 49 17
insertion row 2: 29 40 83 15 79 65 70 9 49 17
insertion row 3: 15 29 40 83 79 65 70 9 49 17
insertion row 4: 15 29 40 79 83 65 70 9 49 17
insertion row 5: 15 29 40 65 79 83 70 9 49 17
insertion row 6: 15 29 40 65 70 79 83 9 49 17
insertion row 7: 9 15 29 40 65 70 79 83 49 17
insertion row 8: 9 15 29 40 49 65 70 79 83 17
insertion row 9: 9 15 17 29 40 49 65 70 79 83
insertion row 10: 9 15 17 29 40 49 65 70 79 83
insertion end : 9 15 17 29 40 49 65 70 79 83
```
